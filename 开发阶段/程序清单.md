# åŸºäºpythonçš„è‹±è¯­å‘éŸ³ä¾‹å¥åº“æ¥å£ï¼šç¨‹åºæ¸…å•

**Pythonè¯¾ç¨‹è®¾è®¡å°ç»„ï¼šå¼ ä¸€é¸£ï¼Œå¼ æ™“è‰ºï¼Œæ½˜æ˜Š**

**ç»„é•¿ï¼šå¼ ä¸€é¸£**

## æ–‡æ¡£ä¿®æ”¹è®°å½•



| ç‰ˆæœ¬å· | ç‰ˆæœ¬æè¿°     | è´£ä»»äºº | æ—¥æœŸ      | å¤‡æ³¨ |
| ------ | ------------ | ------ | --------- | ---- |
| V1.0   | åˆå§‹ç¼–åˆ¶     | å¼ ä¸€é¸£ | 2020-6-26  |      |

## 1.å½±ç‰‡è‡ªåŠ¨è£åˆ‡æ¨¡å—

### 1.1 ä¾‹å¥éš¾åº¦é—´æ–­ç‚¹åˆ†æå™¨

ç”¨äºåˆ†æå¥å­çš„éš¾åº¦åˆ†çº§ç‚¹ã€‚

```python
#fast_jenks_breaks_test.py
import jenkspy
from analyser.caption_factory import CaptionFactory


def cut(li, low, high):
    new_list = []
    for i in li:
        if low < i <= high:
            new_list.append(i)
    return len(new_list)


s_list = CaptionFactory.load_dir(r"H:\å¼€å‘\æ ·æœ¬\film spliter\å­—å¹•åŸæ–‡ä»¶", 0, "")
num_list = [len(s.s_en) for s in s_list]
breaks = jenkspy.jenks_breaks(num_list, 3)
print("min="+str(min(num_list))+",max="+str(max(num_list))+",breaks="+str(breaks))
print("%s<x<=%s:%s\n%s<x<=%s:%s\n%s<x<=%s:%s\n" % (str(min(num_list)), str(breaks[1]), cut(num_list, 11, 45), str(breaks[1]), str(breaks[2]), cut(num_list, 45, 94), str(breaks[2]), str(max(num_list)), cut(num_list, 94, 296)))
for s in s_list:
    if len(s.s_en) == breaks[3]:
        print(s.s_en+"\n"+s.s_cn)
        break

```

### 1.2 å­—å¹•è‡ªåŠ¨é‡å‘½åå·¥å…·

å¯¹å­—å¹•æ–‡ä»¶çš„åå­—è¿›è¡Œä¿®æ”¹ï¼Œä»¥ä¾¿ä¿ç•™å…¶æ­£ç¡®çš„å½±ç‰‡åã€‚

```python
#auto_rename_tool.py
# è¿™æ˜¯ä¸€ä¸ªè‡ªåŠ¨é‡å‘½åå·¥å…·ï¼Œç”±äºæœ¬è½¯ä»¶åªæ¥å—ä¸­è‹±å…±æœ‰çš„å­—å¹•ï¼Œæ­¤ç±»å­—å¹•ä¸‹è½½åå‡æœ‰'.ç®€ä½“&è‹±æ–‡'åç¼€ï¼Œ
# è‹¥ä¸å»é™¤åˆ™ä¼šè¢«å½“ä½œç”µå½±åçš„ä¸€éƒ¨åˆ†ä¸Šä¼ åˆ°æ•°æ®åº“ï¼Œéœ€ç”¨æ­¤å·¥å…·è‡ªåŠ¨å‘½åæ‰èƒ½åˆ†æ
# è¿™é‡Œé»˜è®¤çš„å­—å¹•ä½ç½®æ˜¯settingä¸­çš„caption_path
import os
from xml.etree.ElementTree import *


def decode_xml():
    setting = parse('setting.xml')
    path = None
    for item in setting.iterfind('path'):
        path = item.findtext('caption_path')
    return path


if __name__ == '__main__':
    path = decode_xml()
    files = os.listdir(path)
    for file in files:
        if '.ç®€ä½“&è‹±æ–‡' in file:
            old = file
            new = file.replace('.ç®€ä½“&è‹±æ–‡', '')
            os.rename(path+'\\'+file, path+'\\'+new)
            print(old+'----->'+new)
    print('all done!')

```

### 1.3 ä¸»ç¨‹åº

å¯¹æŒ‡å®šä½ç½®çš„å­—å¹•è¿›è¡Œåˆ†æï¼Œå¹¶å¯»æ‰¾å…¶å…±åŒç›®å½•ä¸‹çš„ç”µå½±åˆ‡å‰²ä¸ºéŸ³é¢‘æ–‡ä»¶ï¼ŒåŒæ—¶å°†åˆ†æç»“æœä¸Šä¼ åˆ°æ•°æ®åº“ã€‚

```python
#program.py
from analyser.analyser import *
import traceback
import time


# åœ¨å½“å‰è·¯å¾„å†™å…¥æ‰§è¡Œç»“æœ
def write_doc(content_str: str):
    content = 'date:'+time.asctime(time.localtime(time.time()))+'\n' \
              '================================================\n'+ content_str
    doc_file = open('runtime_doc.txt', 'w', encoding='utf-8')
    doc_file.write(content)
    doc_file.close()

if __name__=='__main__':
    try:
        an = Analyser()
    except Exception as e:
        c = 'Exception Happened:\nstr(Exception):\t%s\nstr(e):\t%s\nrepr(e):\t%s\ntraceback.print_exc():\t%s\ntraceback.format_exc():\n%s' % \
            (str(Exception), str(e), repr(e), traceback.print_exc(), traceback.format_exc())
        write_doc(c)
    else:
        c = 'Done!\nword_count:\t%s\nsentence_count:\t%s\nAll data have been uploaded in database.' % \
            (str(len(an.word_list)), str(len(an.sentence_list)))
        write_doc(c)

```

**æ³¨ï¼šç¨‹åºå¯åŠ¨éœ€è¦æ¥å—ä¸€ä¸ªé…ç½®æ–‡ä»¶ï¼ˆsetting.xmlï¼‰å…¶æ ‡å‡†å¦‚ä¸‹ï¼š**

```xml
<?xml version="1.0" encoding="utf-8" ?>
<setting>
    <description>
        <app>pyfilm-spliter</app>
        <ver>1.0</ver>
    </description>
    <path>
        <caption_path>è¿™é‡Œå¡«å†™å­—å¹•ä¸å¯¹äºè§†é¢‘çš„ç›®å½•</caption_path>
        <audio_path>è¿™é‡Œå¡«å†™éŸ³é¢‘è¾“å‡ºç›®å½•</audio_path>
    </path>
    <database>
        <server>æ•°æ®åº“åœ°å€</server>
        <user>æ•°æ®åº“ç”¨æˆ·å</user>
        <password>æ•°æ®åº“å¯†ç </password>
        <db_name>æ•°æ®åº“å</db_name>
    </database>
</setting>
```

### 1.4 åˆ†æå™¨

å­—å¹•åˆ†ææ¨¡å—ï¼Œæ— æ³•ç‹¬ç«‹è¿è¡Œ

```python
#analyser.analyser.py
import analyser.caption_factory
import data_connector.model_sentence
import data_connector.model_word
import data_connector.data_manager
from xml.etree.ElementTree import *
import re


class Analyser:
    @property
    def sentence_list(self):
        return self.__sentence_list

    @sentence_list.setter
    def sentence_list(self, value):
        self.__sentence_list = value

    @property
    def word_list(self):
        return self.__word_list

    @word_list.setter
    def word_list(self, value):
        self.__word_list = value

    def __init__(self, start_id: int = 0):
        self.__db_setting = self.__decode_xml()
        print('åˆ†è§£å­—å¹•æ–‡ä»¶å¹¶åˆ†å‰²è§†é¢‘....')
        self.__sentence_list = analyser.caption_factory.CaptionFactory.load_dir(self.__caption_path, start_id, self.__audio_path)
        self.__word_list = []
        dm = data_connector.data_manager.DataManager(self.__db_setting)
        print('åˆ†æä¾‹å¥å¹¶ä¸Šä¼ ....')
        for sentence in self.__sentence_list:
            self.__split_word(sentence)
            dm.execute_sql(sentence.to_sql())
        print('ä¸Šä¼ åˆ†æç»“æœ....')
        for word in self.__word_list:
            dm.execute_sql(word.to_sql())
        dm.close_connection()
        print('ä½œä¸šç»“æŸã€‚')

    # ä»ä¾‹å¥ä¸­åˆ†å‰²å‡ºå•è¯å¹¶ä¿å­˜
    def __split_word(self, sentence: data_connector.model_sentence.ModelSentence):
        words = sentence.s_en.split(' ')
        dm = data_connector.data_manager.DataManager(self.__db_setting)
        for word in words:
            clean_word = re.sub('[,.!?:]', '', word.lower())
            trans = dm.get_translation(clean_word)
            if trans:
                is_include = False
                for word_model in self.__word_list:
                    if clean_word == word_model.word:
                        word_model.sentences += '|' + str(sentence.s_id)
                        is_include = True
                if not is_include:
                    self.__word_list.append(data_connector.model_word.ModelWord(clean_word, str(sentence.s_id), trans))
        dm.close_connection()

    # è§£æxmlæ–‡ä»¶
    def __decode_xml(self):
        db_setting = {}
        setting = parse('.\\setting.xml')
        for item in setting.iterfind('path'):
            self.__caption_path = item.findtext('caption_path')
            self.__audio_path = item.findtext('audio_path')
        for item in setting.iterfind('database'):
            db_setting.update({'server': item.findtext('server')})
            db_setting.update({'user': item.findtext('user')})
            db_setting.update({'password': item.findtext('password')})
            db_setting.update({'database': item.findtext('db_name')})
        return db_setting

```

```python
#analyser.tick.py
# ä¸€ä¸ªé‡æ„çš„æ—¶é—´ç±»ï¼Œé€šè¿‡strå¯ä»¥å¾—åˆ°moviepyè£åˆ‡ç”µå½±çš„æ ‡å‡†æ—¶åˆ»å­—ç¬¦ä¸²
class Tick:

    @property
    def hour(self):
        return self.__hour

    @hour.setter
    def hour(self, value: int):
        self.__hour = value

    @property
    def min(self):
        return self.__min

    @min.setter
    def min(self, value: int):
        self.__min = value

    @property
    def sec(self):
        return self.__sec

    @sec.setter
    def sec(self, value: int):
        self.__sec = value

    @property
    def min_sec(self):
        return self.__min_sec

    @min_sec.setter
    def min_sec(self, value: int):
        self.__min_sec = value

    def __init_prop(self, tick_string: str):
        tick_fragment = tick_string.split(':')
        sec_fragment = tick_fragment[2].split(',')
        self.__hour = int(tick_fragment[0])
        self.__min = int(tick_fragment[1])
        self.__sec = int(sec_fragment[0])
        self.__min_sec = int(sec_fragment[1])

    def __init__(self, tick_string: str=None):
        if tick_string is not None:
            self.__init_prop(tick_string)
        else:
            self.__hour = 0
            self.__min = 0
            self.__sec = 0
            self.__min_sec = 0

    def __sub_digital(self, num: int):
        return str(num//10) if(num > 99) else str(num)

    def __str__(self):
        return str(self.__hour) + ":" + str(self.__min) + ":" + str(self.__sec) + '.' + self.__sub_digital(self.__min_sec)

    def __add__(self, other):
        t_new = Tick()
        t_new.hour = self.hour + other.hour
        t_new.min = self.min + other.min
        t_new.sec = self.sec + other.sec
        t_new.min_sec = self.min_sec + other.min_sec
        return t_new

```

```python
#analyser.caption.py
from .tick import *
from functools import singledispatch


class Caption:
    @property
    def id(self):
        return self.__id

    @id.setter
    def id(self, value: int):
        self.__id = value

    @property
    def start_tick(self):
        return self.__start_tick

    @start_tick.setter
    def start_tick(self, value: Tick):
        self.__start_tick = value

    @property
    def end_tick(self):
        return self.__end_tick

    @end_tick.setter
    def end_tick(self, value: Tick):
        self.__end_tick = value

    @property
    def english(self):
        return self.__english

    @english.setter
    def english(self, value: str):
        self.__english = value

    @property
    def chinese(self):
        return self.__chinese

    @chinese.setter
    def chinese(self, value: str):
        self.__chinese = value

    def __init_prop(self,caption_str: str):
        row_fragments = caption_str.split('\n')
        tick_fragments = row_fragments[1].split('-->')
        self.__id = int(row_fragments[0])
        self.__start_tick = Tick(tick_fragments[0])
        self.__end_tick = Tick(tick_fragments[1])
        self.__chinese = row_fragments[2].replace('\r', '')
        self.__english = row_fragments[3].replace('\r', '')

    @singledispatch
    def __init__(self, caption_str: str=None):
        if caption_str is not None:
            self.__init_prop(caption_str)
        else:
            self.__id = 0
            self.__start_tick = Tick()
            self.__end_tick = Tick()
            self.__chinese = ""
            self.__english = ""

    def __add__(self, other):
        c_new = Caption()
        c_new.id = self.id
        c_new.start_tick = self.start_tick
        c_new.end_tick = other.end_tick
        c_new.english = self.english + ' ' + other.english
        c_new.chinese = self.chinese + ' ' + other.chinese
        return c_new

    def __bool__(self):
        return bool(self.english)

    def __str__(self):
        return self.english

```

```python
#analyser.caption_factory.py
import analyser.caption
import data_connector.model_sentence
import chardet
import re
import os
import film_spliter.spliter
from .caption_merger import CaptionMerger


class CaptionFactory:

    # è½½å…¥å¹¶è§£æä¸€ä¸ªsrtå­—å¹•æ–‡ä»¶ï¼Œè½½å…¥å‰æœ€å¥½ç”¨auto_rename_toolæ¸…æ´—ä¸€ä¸‹æ–‡ä»¶å
    @staticmethod
    def load_srt_file(path: str):
        merger = CaptionMerger()
        regex = re.compile('^\r\n', re.M)
        file_lines = CaptionFactory.__load_file(path)
        for raw_caption in regex.split(file_lines):
            if raw_caption != '':
                temp_caption = analyser.caption.Caption(raw_caption)
                if CaptionFactory.__filter(temp_caption.english):
                    merger.merge_caption(temp_caption)
        return merger.merge_result

    # è½½å…¥å­˜æ”¾srtå­—å¹•æ–‡ä»¶çš„è·¯å¾„ï¼Œæ­¤è·¯å¾„çš„æ‰€æœ‰srtæ–‡ä»¶å°†è¢«è½½å…¥ï¼ŒåŒæ—¶æŸ¥æ‰¾è¯¥è·¯å¾„ä¸‹çš„ç”µå½±ï¼Œæœ‰åˆ™è¢«åˆ†å‰²ä¸ºéŸ³é¢‘ä¾‹å¥æ–‡ä»¶
    @staticmethod
    def load_dir(path: str, id: int, audio_path: str):
        sentence_list = []
        files = os.listdir(path)
        for file in files:
            if file.endswith(".srt"):
                is_have_film = CaptionFactory.__find_film(path, file)
                caption_list = CaptionFactory.load_srt_file(path + '\\' + file)
                if not is_have_film:
                    sentence_list += CaptionFactory.__build_sentence_list(id, caption_list, file[:-4])
                else:
                    film_source = path + '\\' + file[:-4] + ".mp4"
                    sentence_list += CaptionFactory.__build_sentence_list(id, caption_list, file[:-4], film_source, audio_path)
                id += len(caption_list)
        return sentence_list

    # å¯»æ‰¾pathè·¯å¾„ä¸‹ä¸srt_nameåç§°ç›¸åŒçš„mp4æ–‡ä»¶ï¼ˆç”µå½±ï¼‰
    @staticmethod
    def __find_film(path, srt_name):
        is_found = False
        files = os.listdir(path)
        for file in files:
            if file.endswith(".mp4"):
                if file[: -4] == srt_name[: -4]:
                    is_found = True
                    break
        return is_found

    # è½½å…¥å­—å¹•æ–‡ä»¶ï¼ŒåŒæ—¶åˆ†æå…¶å­—ç¬¦ç¼–ç ï¼Œç¡®ä¿æ²¡æœ‰ä¹±ç ã€‚
    @staticmethod
    def __load_file(path: str):
        file = open(path, 'rb')
        file_raw_lines = file.read()
        file.close()
        encoding_res = chardet.detect(file_raw_lines)
        return file_raw_lines.decode(encoding_res['encoding'], errors='ignore')

    # è¿‡æ»¤å¥å­ï¼Œç­›é€‰æ‰ä¸èƒ½åŠ å…¥æ•°æ®åº“çš„å¥å­ã€‚
    @staticmethod
    def __filter(sentence: str):
        return len(sentence) > 10 and not re.search('[^A-z.,?!\"\'\- \r]', sentence)

    # å»ºç«‹ä¾‹å¥åˆ—è¡¨ï¼Œè¯¥åˆ—è¡¨å°†è¢«analyser.pyç”¨äºåˆ†æå•è¯
    @staticmethod
    def __build_sentence_list(id: int, caption_list: list, f_name: str, source_film: str=None, target_audio: str=None):
        s_list = []
        for caption in caption_list:
            id += 1
            level = CaptionFactory.__judge_level(caption.english)
            if source_film:
                audio_file = film_spliter.spliter.Spliter.split_to_mp3(source_film, target_audio, caption)
                s_list.append(
                    data_connector.model_sentence.ModelSentence(id, caption, f_name, level, target_audio + "\\" + audio_file))
            else:
                s_list.append(data_connector.model_sentence.ModelSentence(id, caption, f_name, level))
        return s_list

    @staticmethod
    def __judge_level(s: str):
        if len(s) < 45:
            level = 0
        elif len(s) < 94:
            level = 1
        else:
            level = 2
        return level

```

```python
#analyser.caption_merger.py
import re
from .caption import Caption


class CaptionMerger:
    @property
    def merge_result(self):
        return self.__merge_result

    def __init__(self):
        self.__fore_caption = Caption()
        self.__merge_result = []
        self.__merge_count = 0

    def merge_caption(self, c: Caption):
        reg = re.compile('[.!]$|(.")$|(!")$')
        if self.__fore_caption:
            if reg.search(str(c)):
                self.__add_caption(self.__fore_caption + c)
            else:
                self.__merge_middle_caption(c)

        else:
            if reg.search(str(c)):
                self.__add_caption(c)
            else:
                self.__fore_caption = c

    def __add_caption(self, c: Caption):
        if c not in self.__merge_result:
            self.__merge_result.append(c)
            self.__fore_caption = Caption()
            self.__merge_count = 0

    def __merge_middle_caption(self,c: Caption):
        self.__merge_count += 1
        if len(str(self.__fore_caption)) > 100:
            if self.__merge_count > 3:
                self.__add_caption(c)
            else:
                self.__fore_caption += c
        else:
            self.__fore_caption += c
```

### 1.5 æ•°æ®åº“è¿æ¥å™¨

æ•°æ®åº“è¿æ¥æ¨¡å—ï¼Œæ— æ³•ç‹¬ç«‹è¿è¡Œ

```python
#data_connector.model.py
from abc import ABCMeta, abstractmethod


# æŠ½è±¡ç±»Modelï¼Œä¸å¯è¢«å®ä¾‹åŒ–ï¼Œè§„å®šäº†æ‰€æœ‰Modelå­ç±»å…±åŒæ‹¥æœ‰çš„ç¯å¢ƒï¼ˆå³æ•°æ®åº“æ“ä½œæ‰€éœ€è¦çš„ç¯å¢ƒï¼‰
class Model(metaclass=ABCMeta):

    # å°†ç›®å‰çš„å¯¹è±¡è½¬åŒ–ä¸ºæ’å…¥sqlæŒ‡ä»¤ï¼ˆinsert into ....ï¼‰
    @abstractmethod
    def to_sql(self):
        pass

```

```python
#data_connector.model_sentence.py
import data_connector.model
import analyser.caption
import re


class ModelSentence(data_connector.model.Model):
    @property
    def s_id(self):
        return self.__s_id

    @s_id.setter
    def s_id(self, value: int):
        self.__s_id = value

    @property
    def s_en(self):
        return self.__s_en

    @s_en.setter
    def s_en(self, value: str):
        self.__s_en = value

    @property
    def s_cn(self):
        return self.__s_cn

    @s_cn.setter
    def s_cn(self, value: str):
        self.__s_cn = value

    @property
    def s_voice(self):
        if self.__s_voice:
            return "'%s'" % self.__s_voice.replace("\\", '\\\\')
        else:
            return 'null'

    @s_voice.setter
    def s_voice(self, value: str):
        self.__s_voice = value

    @property
    def s_level(self):
        return self.__s_level

    @s_level.setter
    def s_level(self, value: int):
        self.__s_level = value

    @property
    def f_name(self):
        return self.__f_name

    @f_name.setter
    def f_name(self, value: str):
        self.__f_name = value

    def to_sql(self):
        return "insert into t_sentence values (%s,'%s','%s',%s,%s,'%s')" \
               % (str(self.s_id), self.s_en, self.s_cn, self.s_voice, str(self.s_level), self.f_name)

    def __init__(self, id: int, caption: analyser.caption.Caption, f_name: str, level: int, voice_path: str = None):
        self.__s_id = id
        self.__s_en = caption.english.replace('\'', '\\\'')
        self.__s_cn = caption.chinese.replace('\'', '\\\'')
        self.__f_name = f_name
        self.__s_level = level
        self.s_voice = voice_path

```

```python
#data_connector.model_word
import data_connector.model


class ModelWord(data_connector.model.Model):
    @property
    def word(self):
        return self.__word

    @word.setter
    def word(self, value: str):
        self.__word = value

    @property
    def translation(self):
        return self.__translation

    @translation.setter
    def translation(self, value: str):
        self.__translation = value

    @property
    def sentences(self):
        return self.__sentences

    @sentences.setter
    def sentences(self, value: str):
        self.__sentences = value

    def to_sql(self):
        return "insert into t_word values ('%s','%s','%s')" % (self.word, self.translation, self.sentences)

    def __init__(self, word: str, sentences: str, trans: str):
        self.__word = word
        self.__sentences = sentences
        self.__translation = trans

```

```python
#data_connector.data_manager.py
import pymysql


class DataManager:

    def __init__(self, db_setting: dict):
        self.__server = db_setting['server']
        self.__user = db_setting['user']
        self.__password = db_setting['password']
        self.__database = db_setting['database']
        self.__connection = self.build_connection()

    # ä¸æ•°æ®åº“å»ºç«‹è¿æ¥
    def build_connection(self):
        return pymysql.connect(self.__server, self.__user, self.__password, self.__database)

    # æ‰§è¡ŒsqlæŒ‡ä»¤ï¼Œæ³¨æ„åªå¯ä»¥æ‰§è¡Œéœ€è¦commitçš„æŒ‡ä»¤ï¼Œæ¯”å¦‚selectæŸ¥è¯¢ç­‰ä¸èƒ½ä½¿ç”¨ã€‚
    def execute_sql(self, sql: str):
        cursor = self.__connection.cursor()
        is_success = False
        try:
            cursor.execute(sql)
            self.__connection.commit()
            is_success = True
        except:
            self.__connection.rollback()
        return is_success

    # åœ¨æ•°æ®åº“ä¸­æŸ¥è¯¢å•è¯é‡Šä¹‰
    def get_translation(self, word: str):
        if "\'" in word:
            return None
        cursor = self.__connection.cursor()
        cursor.execute("select translation from enwords where word='%s'" % word)
        try:
            res_data = str(cursor.fetchone()[0])
        except TypeError:
            res_data = None
        return res_data

    # å…³é—­ä¸æ•°æ®åº“çš„è¿æ¥
    def close_connection(self):
        self.__connection.close()

```

### 1.6 å½±ç‰‡åˆ†å‰²å™¨

å°†å½±ç‰‡åˆ†å‰²ä¸ºéŸ³é¢‘æ®µçš„æ¨¡å—ï¼Œæ— æ³•ç‹¬ç«‹è¿è¡Œ

```python
#film_spliter.spliter.py
import moviepy.editor
import analyser.caption
import hashlib
import time


class Spliter:
    @staticmethod
    def split_to_mp3(film_path: str, target_path: str, caption: analyser.caption.Caption):
        hash_factory = hashlib.md5((str(time.time())+film_path).encode('utf-8'))
        audio_file_name = hash_factory.hexdigest() + ".mp3"
        film_clip = moviepy.editor.VideoFileClip(film_path)
        film_clip = film_clip.subclip(t_start=str(caption.start_tick), t_end=str(caption.end_tick))
        audio_clip = film_clip.audio
        audio_clip.write_audiofile(target_path+"\\"+audio_file_name)
        film_clip.reader.close()
        film_clip.audio.reader.close_proc()
        return audio_file_name

```

## 2.åç«¯äº¤äº’æ¨¡å—

```python
#app.py
from flask import Flask,request,jsonify
import db_manager
import receive
import check
import send
import json
app = Flask(__name__)
# 0:æˆåŠŸï¼Œ1ï¼šæ²¡æœ‰å•è¯ï¼Œ2ï¼šç”¨æˆ·è®¤è¯å¤±è´¥ï¼Œ3ï¼šä¼ å…¥æ•°æ®æ ¼å¼é”™è¯¯
@app.route("/",methods=["POST"])
#ä¸»äº¤äº’å‡½æ•°
#get_receive_info(raw_info):
#è°ƒç”¨Db_manager.get_send_data(ğŸ‘†)
#è¿”å› get_send_json(send)
def api_main():
    try:
        my_json =request.get_json()
        obj_receive = receive.Receive(my_json)
        if obj_receive.stage==3:
            angle11 = (obj_receive.word, '', [['', '', '', '']], 1)
            angle_send11 = send.Send(3, angle11[0], angle11[1], angle11[2], angle11[3])
            angle_zhazha11 = dict(angle_send11)
            angle_j11 = json.dumps(obj=angle_zhazha11)
            return angle_j11

        obj_check = check.Check(receive=obj_receive)
        print(4)
        result = obj_check.begin_check()
        angle = (obj_receive.word, '', [['', '', '', '']], 1)
        if result != "safe":
            '''åº”ä¸ºresult !="safe:
            return jsonify(result)æ–¹ä¾¿æµ‹è¯•å…¶ä»–æ•°æ®'''
            angle_send = send.Send( 2,angle[0],angle[1],angle[2],angle[3])
            angle_zhazha = dict(angle_send)
            angle_j = json.dumps(obj=angle_zhazha)
            return angle_j
        else:
            obj_db_manager = db_manager.Db_Manager(receive=obj_receive)
            obj_get_word_data = obj_db_manager.get_send_data()
            if obj_get_word_data == "NULL":
                Null_angle_send = send.Send(1, angle[0], angle[1], angle[2], angle[3])
                Null_angle_zhazha = dict(Null_angle_send)
                Null_angle_j = json.dumps(obj=Null_angle_zhazha)
                #è¯¥å•è¯æœªå½•å…¥
                return Null_angle_j
            obj_send = send.Send( 0,obj_get_word_data[0],obj_get_word_data[1],obj_get_word_data[2],obj_get_word_data[3])
            zhazha=dict(obj_send)
            j = json.dumps(obj=zhazha)
            return j

    except Exception as e:
        angle12 =("", '', [['', '', '', '']], 1)
        angle_send = send.Send( 4,angle12[0],angle12[1],angle12[2],angle12[3])
        angle_zhazha = dict(angle_send)
        angle_j = json.dumps(obj=angle_zhazha)
        print("å¼‚å¸¸")
        return angle_j
if __name__ == '__main__':
    app.run()

```

```python
#check.py
#ç”¨äºéªŒè¯åˆæ³•ç”¨æˆ·
import time
import hashlib
import db_manager
class Check():
    def __init__(self,receive):
        # å…è®¸è¶…æ—¶
        self.__over_time = 5
        # è¶…æ—¶æ—¶é—´å†…è®¿é—®çš„MD5å€¼
        self.__visited_dict ={}
        self.client_time = receive.security.time
        self.server_time = time.time()
        self.client_MD5 = receive.security.key
        self.uname =receive.security.uname
        self.receive =receive
        # ç¦æ­¢äº”ç§’å‰çš„è®¿é—®
    def __check_over_time(self):
        client_time = self.client_time
        server_time = self.server_time
        if client_time + 5 < server_time:
            return "è¶…æ—¶ï¼"

    # æŸ¥è¯¢å¹¶æ›´æ–°å­—å…¸ï¼Œç¦æ­¢äº”ç§’å†…é‡å¤çš„è®¿é—®
    def __check_revisit(self):
        '''å­—å…¸éå†æ—¶ä¸èƒ½ä¿®æ”¹å…ƒç´ '''
        for k in list(self.__visited_dict.keys()):
            if int(self.__visited_dict[k]) +5 < self.server_time:
                del self.__visited_dict[k]
                continue
        if self.__visited_dict.get(self.client_MD5)==None:
            self.__visited_dict[self.client_MD5] = self.client_time
        else:return "æ‹’ç»ä½¿ç”¨é‡å¤ä¿¡æ¯"

    # æŸ¥è¯¢æ•°æ®åº“ï¼Œå¾—åˆ°å¯†é’¥+æ—¶é—´æˆ³çš„MD5å€¼
    def __generate_md5(self,u_k):
        u_key = u_k
        self.pwd = str(u_key) + str(self.client_time)
        chachong=self.__visited_dict.get('addr')
        # hashlib.md5åŠ å¯†ä¸æ”¯æŒç±»å‹è½¬æ¢ï¼Œæ•…éƒ½è½¬ä¸ºå­—ç¬¦ä¸²
        self.server_MD5key = hashlib.md5(self.pwd.encode("latin1")).hexdigest()
        if self.server_MD5key != self.client_MD5:
            return "ä¼‘æƒ³"


    # å¼€å§‹æ£€æµ‹
    def begin_check(self):
        message = {}
        message[0] = self.__check_over_time()
        if message[0] == "è¶…æ—¶ï¼":
            return message[0]
        else:
            message[1] = self.__visited_dict
        if message[1] == "æ‹’ç»ä½¿ç”¨é‡å¤ä¿¡æ¯":
            return message[1]
        else:
            self.obj_db = db_manager.Db_Manager(self.receive)
            key = self.obj_db.get_user_data(self)
            message[2] = self.__generate_md5()
            if message[2] == "ä¼‘æƒ³":
                db_manager.Db_Manager.close()
                return message[2]
            else:
                return "safe"


```

```python
#db_manager.py
#ç”¨äºæ•°æ®åº“è¿æ¥æ“ä½œ
import pymysql
class Db_Manager:
    def __init__(self,receive):
        # self.__host ="rm-bp1wkh230i726zd7amo.mysql.rds.aliyuncs.com"# hoståœ°å€
        # self.__port = 3306  # ç«¯å£å·
        # self.__user = "pydev"  # ç”¨æˆ·å
        # self.__password = "vFfMlvDIKyAlzvFNwjnr"  # å¯†ç 
        # self.__db = "pyword_api_test"  # æ•°æ®åº“å
        self.__host ="localhost"# hoståœ°å€
        self.__port = 3306  # ç«¯å£å·
        self.__user = "root"  # ç”¨æˆ·å
        self.__password = "123456"  # å¯†ç 
        self.__db = "water"  # æ•°æ®åº“å
        self.receive = receive
        self.level = receive.option.level
        self.word = receive.word
    # è¿æ¥æ•°æ®åº“
    # è¿”å›è¿æ¥
    def __connect(self):
        conn = pymysql.Connect(
            host=self.__host,
            port=self.__port,
            user=self.__user,
            password=self.__password,
            db=self.__db,
        )
        self.cursor = conn.cursor()  # åˆ›å»ºæ¸¸æ ‡

    #
    # å¾—åˆ°ç”¨æˆ·ä¿¡æ¯
    # ä¼ å…¥ç”¨æˆ·å
    # è¿”å›å¯†é’¥ 0ï¼šä¸å­˜åœ¨è¯¥ç”¨æˆ·

    def get_user_data(self):
        self.__connect()
        name = self.receive.security.uname
        sql = "SELECT * FROM t_user WHERE u_name=%s"

        # sql = 'select * from t_user WHERE u_name = name '
        self.cursor.execute(sql)
        result = self.cursor.fetchall()  # æ¥å—å…¨éƒ¨è¿”å›å†…å®¹
        if result==():
            return 0
        for row in result:
            username = row[0]
            key = row[1]
        self.close()
        return key


    # è¿”å›æ¸¸æ ‡
    # æ–­å¼€è¿æ¥

    def close(self):
        self.cursor.close()
        self.conn.close()

    # å¾—åˆ°è¦å‘é€çš„æ•°æ®
    # è¿”å›Sendç±»
    # è¿”å›å€¼ï¼š1ï¼šæ²¡ç”¨è¯¥å•è¯
    #        0ï¼šæ­£å¸¸æŸ¥è¯¢
    #        2ï¼šæœåŠ¡å™¨é”™è¯¯
    def get_send_data(self):
        self.__connect()
        word =self.word
        sql = "SELECT * FROM t_word WHERE word=%s"
        self.cursor.execute(sql,word)
        result = self.cursor.fetchall()  # æ¥å—å…¨éƒ¨è¿”å›å†…å®¹

        if result ==():
            return "NULL"

        for row in result:
            wordT = row[0]
            word_translation = row[1]
            sentences = row[2]

        if wordT is None:
            self.close()
            return 1

        sentences_bak=self.get_sentences(sentences=sentences)
        length =sentences_bak[1]
        sentences_list =sentences_bak[0]
        '''æ¥æ”¶çš„ç»“æœä¸ºä¸€ä¸ªä¸‰ç»´æ•°ç»„'''
        return (self.word,word_translation,sentences_list,length)

    def get_sentences(self,sentences):
        sentences_id = sentences.split("|")  # åˆ‡å‰²å¥å­id
        sentences_list = [[0] * 4 for i in range(len(sentences_id))]  # åˆ›å»ºåˆ—è¡¨å­˜æ¯ä¸ªå¥å­
        z = 0
        for i in range(len(sentences_id)):
            sql = "SELECT * FROM t_sentence WHERE id=%s"
            self.cursor.execute(sql, sentences_id[i])
            result = self.cursor.fetchall()  # æ¥å—å…¨éƒ¨è¿”å›å†…å®¹

            for row in result:
                s_en = row[1]
                s_cn = row[2]
                s_voice = row[3]
                s_level = row[4]
                f_name = row[5]
            if s_level == self.level:
                sentences_list[z][0] = f_name
                sentences_list[z][1] = s_cn
                sentences_list[z][2] = s_en
                sentences_list[z][3] = s_voice
                z = z + 1
        dd = [[0] * 4 for i in range(len(sentences_id))]
        length = z
        jh = 0
        for s_i in range(length):
            for s_j in range(length):
                aaa=0
                if (sentences_list[s_i][2] == sentences_list[s_j][2])and(aaa!=s_i):
                    break
                else:
                    if aaa == s_i:
                        dd[jh][0] = sentences_list[s_i][0]
                        dd[jh][1] = sentences_list[s_i][1]
                        dd[jh][2] = sentences_list[s_i][2]
                        dd[jh][3] = sentences_list[s_i][3]
                        jh =jh+1
                    aaa = aaa + 1
            return(dd,jh)
```

```python
#receive.py
#ç”¨äºæ¥å—ä¿¡æ¯
class Security:
    # åˆå§‹åŒ–Security
    # ä¼ å…¥ç”¨æˆ·åã€MD5ï¼ˆkey+æ—¶é—´æˆ³ï¼‰ã€æ—¶é—´æˆ³
    def __init__(self, security_dict):
        self.uname = security_dict['uname']
        self.stage=0
        if self.uname=="":
            self.stage=3
        elif type(self.uname)!=str:
            self.stage = 3
        self.key = security_dict['key']
        if self.key == "":
            self.stage = 3
        elif type(self.key) != str:
            self.stage = 3
        self.time = security_dict['time']
        if self.uname == "":
            self.stage = 3
        elif type(self.time) != float:
            self.stage = 3


class Option:
    # åˆå§‹åŒ–Option
    # ä¼ å…¥ä¾‹å¥éš¾åº¦
    def __init__(self, option_dict):
        self.stage=0
        self.level = option_dict['level']
        if self.level == "":
            self.stage = 3
        elif type(self.level) != int:
            self.stage = 3

class Receive:
    # åˆå§‹åŒ–æ¥æ”¶ç±»
    # ä¼ å…¥æ¥æ”¶çš„å‚æ•°
    def __init__(self, receive_dict):
        self.stage=0
        self.receive_dict_security = receive_dict['security']
        if self.receive_dict_security =="":
            self.stage = 3
        elif type(self.receive_dict_security) != dict:
            self.stage = 3
        self.security = Security(receive_dict['security'])
        if self.security.stage == 3:
            self.stage = 3
        self.word = receive_dict['word']

        if self.word =="":
            self.stage = 3
        elif type(self.word)!=str:
            self.stage = 3
        self.receive_dict_option = receive_dict['option']
        if self.receive_dict_option == "":
            self.stage = 3
        elif type(self.receive_dict_option)!= dict:
            self.stage = 3
        self.option = Option( receive_dict['option'])
        if self.option.stage==3:
            self.stage = 3



```

```python
#send.py
#ç”¨äºå‘å®¢æˆ·ç«¯å‘é€æ•°æ®

class Sentence(object):
    # åˆå§‹åŒ–ä¾‹å¥
    # ä¼ å…¥è‹±æ–‡ã€ä¸­æ–‡ä¾‹å¥å’ŒéŸ³é¢‘æ–‡ä»¶åœ°å€ã€æ‰€å±ç”µå½±
    def __init__(self, f_name, en ,cn , voice):
        self.f_name = f_name
        self.en = en
        self.cn = cn
        self.voice = voice

    def keys(self):
        '''å½“å¯¹å®ä¾‹åŒ–å¯¹è±¡ä½¿ç”¨dict(obj)çš„æ—¶å€™, ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•,è¿™é‡Œå®šä¹‰äº†å­—å…¸çš„é”®, å…¶å¯¹åº”çš„å€¼å°†ä»¥obj['name']çš„å½¢å¼å–,
        ä½†æ˜¯å¯¹è±¡æ˜¯ä¸å¯ä»¥ä»¥è¿™ç§æ–¹å¼å–å€¼çš„, ä¸ºäº†æ”¯æŒè¿™ç§å–å€¼, å¯ä»¥ä¸ºç±»å¢åŠ ä¸€ä¸ªæ–¹æ³•'''
        return ( "f_name", "en" , "cn" , "voice")

    def __getitem__(self, item):
        '''å†…ç½®æ–¹æ³•, å½“ä½¿ç”¨obj['name']çš„å½¢å¼çš„æ—¶å€™, å°†è°ƒç”¨è¿™ä¸ªæ–¹æ³•, è¿™é‡Œè¿”å›çš„ç»“æœå°±æ˜¯å€¼'''
        return getattr(self, item)

class Send:
    # åˆå§‹åŒ–å‘é€ç±»
    # ä¼ å…¥çŠ¶æ€ç ã€æŸ¥è¯¢å•è¯ã€ä¸­æ–‡é‡Šä¹‰å’Œä¾‹å¥åˆ—è¡¨
    def __init__(self, statue, word, trans, sentence_list,length):
        self.statue =statue
        self.word = word
        self.trans = trans
        self.sentences = self.sentsss(sentence_list,length)

    def keys(self):
        return ('statue','word','trans' ,'sentences')

    def __getitem__(self, item):
        return getattr(self, item)

    def sentsss(self,sentence_list,length):
        vam =[]
        sent = sentence_list
        for i in range(length):
            hhh =dict(Sentence(sent[i][0], sent[i][1], sent[i][2], sent[i][3]))
            vam.append(hhh)
        return vam

```